Name: Get Equal Substrings Within Budget
Type: Algorithm
Difficulty: Medium
From: LeetCode

Description:
    Given two strings, "s" and "t", of the same length and an integer "MaxCost", change s to t. Return the maximum length
    of substring s that can be changed to the same substring of t with a cost less than or equal to MaxCost. If there is no
    possible change that can occur, then return 0.
    
    Changing the ith character of s to the ith character of t costs |s[i] - t[i]|, which is the absolute difference between
    the ASCII values of the characters.

Assumptions:
    - s.length >= 1
    - t.length >= 1
    - Maxcost >= 0
    - s and t can only consist of English lowercase letters.

Example:
    Input: s = "abcd", t = "bcdf", maxCost = 3
    Output: 3

    Input: s = "abcd", t = "acde", maxCost = 0
    Output: 1


Solution Explanation:
    Sliding Window, O(N):
        A sliding window algorithm can give us a an answer by adjusting the size of the substring ensuring that it follows
        the max cost constraint. We can slide our solution along the whole string, and ensure that given a substring, we can
        both achieve the largest possible substring while maintaining cost constraints by checking through our sliding window
        if we go over the cost constraint or not. Everytime we go over the constraint, we slide the whole window forward,
        and check if the new substring size in teh window is greater than all previous substrings seen.

        Algorithm Pseudocode:
            Solution {
                sub_len = 0
                ptr1 = 0
                cost = 0

                for (ptr2 = 0; ptr2 < s.length; s++) {
                    cost += abs(char_to_int(s[ptr2]) - char_to_int(t[ptr2]))

                    while (cost > max_cost) {
                        cost -= abs(char_to_int(s[ptr1]) - char_to_int(t[ptr1]))
                        ptr1 += 1
                    }

                    sub_len = max(sub_len, ptr2 - ptr1 + 1)
                }

                return sub_len
            }

        Proof of Correctness:
            We note that we can divide "s" into a number of substrings by the maxCost variable. Doing this, we can generate a 
            series of substrings of s which all abide to the maxCost. These potential substrings are generated by the sliding
            window, in which each window does the following when it hits the maxCost constraint for a generated substring.
                - A previous substring, stored in sub_len, is already found, in which case we keep this longer substring.
                - The current window's substring is larger, if so, sub_len is replaced by the current window.
            
            We note that in the cases above, that we can obtain the largest generated substring through the given
            length calculation, and essentially, the string "s" can be broken into segments of costs, which our sliding window
            will accuartely find, and because we will always choose the largest substring, we are guaranteed to find the correct asnwer.

        Proof of Runtime:
            Because we visit each character once through the sliding window, we note that the runtime if O(N).